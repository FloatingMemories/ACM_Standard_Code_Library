# 图论

## 最近公共祖先

```cpp
const LL N = 5e5+10, SP = log2(N)+1;
vector<int> G[N];
int pa[N][SP], dep[N];

void dfs(int u, int fa) {
	pa[u][0] = fa; dep[u] = dep[fa] + 1;
	FOR (i, 1, SP) pa[u][i] = pa[pa[u][i - 1]][i - 1];
	for (int& v: G[u]) {
		if (v == fa) continue;
		dfs(v, u);
	}
}

int lca(int u, int v) {
	if (dep[u] < dep[v]) swap(u, v);
	int t = dep[u] - dep[v];
	FOR (i, 0, SP) if (t & (1 << i)) u = pa[u][i];
	FORD (i, SP - 1, -1) {
		int uu = pa[u][i], vv = pa[v][i];
		if (uu != vv) { u = uu; v = vv; }
	}
	return u == v ? u : pa[u][0];
}
```

## 网络流

- 最大流

```cpp
const LL INF = LONG_LONG_MAX;

struct E {
	LL to, cp;
	E(LL to, LL cp): to(to), cp(cp) {}
};

struct Dinic {
	static const LL M = 1E5 * 5;
	LL m, s, t;
	vector<E> edges;
	vector<LL> G[M];
	LL d[M];
	LL cur[M];
	
	void init(LL n, LL s, LL t) {
		this->s = s; this->t = t;
		for (LL i = 0; i <= n; i++) G[i].clear();
		edges.clear(); m = 0;
	}
	
	void addedge(LL u, LL v, LL cap) {
		edges.emplace_back(v, cap);
		edges.emplace_back(u, 0);
		G[u].push_back(m++);
		G[v].push_back(m++);
	}
	
	bool BFS() {
		memset(d, 0, sizeof d);
		queue<LL> Q;
		Q.push(s); d[s] = 1;
		while (!Q.empty()) {
			LL x = Q.front(); Q.pop();
			for (LL& i: G[x]) {
				E &e = edges[i];
				if (!d[e.to] && e.cp > 0) {
					d[e.to] = d[x] + 1;
					Q.push(e.to);
				}
			}
		}
		return d[t];
	}
	
	LL DFS(LL u, LL cp) {
		if (u == t || !cp) return cp;
		LL tmp = cp, f;
		for (LL& i = cur[u]; i < G[u].size(); i++) {
			E& e = edges[G[u][i]];
			if (d[u] + 1 == d[e.to]) {
				f = DFS(e.to, min(cp, e.cp));
				e.cp -= f;
				edges[G[u][i] ^ 1].cp += f;
				cp -= f;
				if (!cp) break;
			}
		}
		return tmp - cp;
	}
	
	LL go() {
		LL flow = 0;
		while (BFS()) {
			memset(cur, 0, sizeof cur);
			flow += DFS(s, INF);
		}
		return flow;
	}
} DC;
```

- 最小费用最大流

```cpp
const LL M = 5e4+10;
const int INF = INT_MAX;

struct E {
	int from, to, cp, v;
	E() {}
	E(int f, int t, int cp, int v) : from(f), to(t), cp(cp), v(v) {}
};

struct MCMF {
	int n, m, s, t;
	vector<E> edges;
	vector<int> G[M];
	bool inq[M];
	int d[M], p[M], a[M];
	
	void init(int _n, int _s, int _t) {
		n = _n; s = _s; t = _t;
		FOR (i, 0, n + 1) G[i].clear();
		edges.clear(); m = 0;
	}
	
	void addedge(int from, int to, int cap, int cost) {
		edges.emplace_back(from, to, cap, cost);
		edges.emplace_back(to, from, 0, -cost);
		G[from].push_back(m++);
		G[to].push_back(m++);
	}
	
	bool BellmanFord(int &flow, int &cost) {
		FOR (i, 0, n + 1) d[i] = INF;
		memset(inq, 0, sizeof inq);
		d[s] = 0, a[s] = INF, inq[s] = true;
		queue<int> Q; Q.push(s);
		while (!Q.empty()) {
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for (int& idx: G[u]) {
				E &e = edges[idx];
				if (e.cp && d[e.to] > d[u] + e.v) {
					d[e.to] = d[u] + e.v;
					p[e.to] = idx;
					a[e.to] = min(a[u], e.cp);
					if (!inq[e.to]) {
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if (d[t] == INF) return false;
		flow += a[t];
		cost += a[t] * d[t];
		int u = t;
		while (u != s) {
			edges[p[u]].cp -= a[t];
			edges[p[u] ^ 1].cp += a[t];
			u = edges[p[u]].from;
		}
		return true;
	}
	
	pair<int, int> go() {
		int flow = 0, cost = 0;
		while (BellmanFord(flow, cost));
		return {flow, cost};
	}
} MM;
```

## 树上路径交

- 前置模板：最近公共祖先

```cpp
int intersection(int x1, int y1, int x2, int y2) {
	int t[4] = {lca(x1, x2), lca(x1, y2), lca(y1, x2), lca(y1, y2)};
	int p1 = 0,p2 = 0;
	FOR(j,0,4)
	if(dep[t[j]] > dep[p1]) p2 = p1, p1 = t[j];
	else if(dep[t[j]] > dep[p2]) p2 = t[j];
	int h1 = lca(x1,y1), h2 = lca(x2,y2);
	if(p1 == p2){
		if(dep[p1] < dep[h1] || dep[p1] < dep[h2]) return 0;
		else return 1;
	}
	else{
		int ans = dep[p1]+dep[p2]-2*dep[lca(p1,p2)]+1;
		return ans;
	}
}
```

## 树上点分治（树的重心）

```cpp
const LL N = 2e4+10, N2 = N * 2;

int h[N], e[N2], ne[N2], idx;

void add(int a, int b){
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

vector<bool> vis;

// 获取子树的重心（自动处理父子关系）(如果有两个重心，输出编号小的那个)
// 若重心为u，则mx[u]为以u为重心子树大小的最大值
int q[N], fa[N], sz[N], mx[N];
int get_rt(int u) { 
	int p = 0, cur = -1;
	q[p++] = u; fa[u] = -1;
	while (++cur < p) {
		u = q[cur]; mx[u] = 0; sz[u] = 1;
		for (int i = h[u]; i!=-1; i=ne[i]){
			int j = e[i];
			if(vis[j] or j == fa[u]) continue;
			fa[q[p++] = j] = u;
		}
	}
	FORD (i, p - 1, -1) {
		u = q[i];
		mx[u] = max(mx[u], p - sz[u]);
		if (mx[u] * 2 <= p) return u;
		sz[fa[u]] += sz[u];
		mx[fa[u]] = max(mx[fa[u]], sz[u]);
	}
//	assert(0);
}

// 分治dfs（起点任意）
void dfs(int u) {
	cout << "u: " << u;
	u = get_rt(u);
	vis[u] = true;
	// 处理子树逻辑
	cout << " centroid: " << u << '\n';
	// 如果在此处DFS，会遍历整棵子树（if(vis[u]) return）
	// ...
	
	for(int i=h[u]; i!=-1; i=ne[i]){
		int j = e[i];
		if(vis[j]) continue;
		dfs(j);
	}
}
```

## 二分图

### 最大匹配

+ 最小覆盖数 = 最大匹配数
+ 最大独立集 = 顶点数 - 二分图匹配数
+ DAG 最小路径覆盖数 = 结点数 - 拆点后二分图最大匹配数

```cpp
const int N = 500+10;

struct MaxMatch {
	int n;
	vector<int> G[N];
	int vis[N], left[N], clk;
	
	void init(int n) {
		this->n = n;
		FOR (i, 0, n + 1) G[i].clear();
		memset(left, -1, sizeof left);
		memset(vis, -1, sizeof vis);
	}
	
	bool dfs(int u) {
		for (int v: G[u])
			if (vis[v] != clk) {
				vis[v] = clk;
				if (left[v] == -1 || dfs(left[v])) {
					left[v] = u;
					return true;
				}
			}
		return false;
	}
	
	int match() {
		int ret = 0;
		for (clk = 0; clk <= n; ++clk)
			if (dfs(clk)) ++ret;
		return ret;
	}
} MM;
// !!!!!!!!!!!!!!!!!!!!!!!!!!! Tester Start !!!!!!!!!!!!!!!!!!!!!!!!!!!!
void solve(){
	LL n1, n2, m, n, i, t1, t2;
	cin >> n1 >> n2 >> m;
	n = n1 + n2;
	MM.init(n);
	for(i=0; i<m; i++){
		cin >> t1 >> t2;
		MM.G[t1].push_back(n1+t2);
	}
	cout << MM.match() << '\n';
}
```

