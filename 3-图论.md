# 图论

## 树的重心

- 以树的重心为根，则其子树大小的最大值最小

```cpp

```



## 最近公共祖先

```cpp
const LL N = 5e5+10, SP = log2(N)+1;
vector<int> G[N];
int pa[N][SP], dep[N];

void dfs(int u, int fa) {
	pa[u][0] = fa; dep[u] = dep[fa] + 1;
	FOR (i, 1, SP) pa[u][i] = pa[pa[u][i - 1]][i - 1];
	for (int& v: G[u]) {
		if (v == fa) continue;
		dfs(v, u);
	}
}

int lca(int u, int v) {
	if (dep[u] < dep[v]) swap(u, v);
	int t = dep[u] - dep[v];
	FOR (i, 0, SP) if (t & (1 << i)) u = pa[u][i];
	FORD (i, SP - 1, -1) {
		int uu = pa[u][i], vv = pa[v][i];
		if (uu != vv) { u = uu; v = vv; }
	}
	return u == v ? u : pa[u][0];
}
```

## 网络流

- 最大流

```cpp
const LL INF = LONG_LONG_MAX;

struct E {
	LL to, cp;
	E(LL to, LL cp): to(to), cp(cp) {}
};

struct Dinic {
	static const LL M = 1E5 * 5;
	LL m, s, t;
	vector<E> edges;
	vector<LL> G[M];
	LL d[M];
	LL cur[M];
	
	void init(LL n, LL s, LL t) {
		this->s = s; this->t = t;
		for (LL i = 0; i <= n; i++) G[i].clear();
		edges.clear(); m = 0;
	}
	
	void addedge(LL u, LL v, LL cap) {
		edges.emplace_back(v, cap);
		edges.emplace_back(u, 0);
		G[u].push_back(m++);
		G[v].push_back(m++);
	}
	
	bool BFS() {
		memset(d, 0, sizeof d);
		queue<LL> Q;
		Q.push(s); d[s] = 1;
		while (!Q.empty()) {
			LL x = Q.front(); Q.pop();
			for (LL& i: G[x]) {
				E &e = edges[i];
				if (!d[e.to] && e.cp > 0) {
					d[e.to] = d[x] + 1;
					Q.push(e.to);
				}
			}
		}
		return d[t];
	}
	
	LL DFS(LL u, LL cp) {
		if (u == t || !cp) return cp;
		LL tmp = cp, f;
		for (LL& i = cur[u]; i < G[u].size(); i++) {
			E& e = edges[G[u][i]];
			if (d[u] + 1 == d[e.to]) {
				f = DFS(e.to, min(cp, e.cp));
				e.cp -= f;
				edges[G[u][i] ^ 1].cp += f;
				cp -= f;
				if (!cp) break;
			}
		}
		return tmp - cp;
	}
	
	LL go() {
		LL flow = 0;
		while (BFS()) {
			memset(cur, 0, sizeof cur);
			flow += DFS(s, INF);
		}
		return flow;
	}
} DC;
```

- 最小费用最大流

```cpp
const LL M = 5e4+10;
const int INF = INT_MAX;

struct E {
	int from, to, cp, v;
	E() {}
	E(int f, int t, int cp, int v) : from(f), to(t), cp(cp), v(v) {}
};

struct MCMF {
	int n, m, s, t;
	vector<E> edges;
	vector<int> G[M];
	bool inq[M];
	int d[M], p[M], a[M];
	
	void init(int _n, int _s, int _t) {
		n = _n; s = _s; t = _t;
		FOR (i, 0, n + 1) G[i].clear();
		edges.clear(); m = 0;
	}
	
	void addedge(int from, int to, int cap, int cost) {
		edges.emplace_back(from, to, cap, cost);
		edges.emplace_back(to, from, 0, -cost);
		G[from].push_back(m++);
		G[to].push_back(m++);
	}
	
	bool BellmanFord(int &flow, int &cost) {
		FOR (i, 0, n + 1) d[i] = INF;
		memset(inq, 0, sizeof inq);
		d[s] = 0, a[s] = INF, inq[s] = true;
		queue<int> Q; Q.push(s);
		while (!Q.empty()) {
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for (int& idx: G[u]) {
				E &e = edges[idx];
				if (e.cp && d[e.to] > d[u] + e.v) {
					d[e.to] = d[u] + e.v;
					p[e.to] = idx;
					a[e.to] = min(a[u], e.cp);
					if (!inq[e.to]) {
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if (d[t] == INF) return false;
		flow += a[t];
		cost += a[t] * d[t];
		int u = t;
		while (u != s) {
			edges[p[u]].cp -= a[t];
			edges[p[u] ^ 1].cp += a[t];
			u = edges[p[u]].from;
		}
		return true;
	}
	
	pair<int, int> go() {
		int flow = 0, cost = 0;
		while (BellmanFord(flow, cost));
		return {flow, cost};
	}
} MM;
```

## 树上路径交

- 前置模板：最近公共祖先

```cpp
int intersection(int x1, int y1, int x2, int y2) {
	int t[4] = {lca(x1, x2), lca(x1, y2), lca(y1, x2), lca(y1, y2)};
	int p1 = 0,p2 = 0;
	FOR(j,0,4)
	if(dep[t[j]] > dep[p1]) p2 = p1, p1 = t[j];
	else if(dep[t[j]] > dep[p2]) p2 = t[j];
	int h1 = lca(x1,y1), h2 = lca(x2,y2);
	if(p1 == p2){
		if(dep[p1] < dep[h1] || dep[p1] < dep[h2]) return 0;
		else return 1;
	}
	else{
		int ans = dep[p1]+dep[p2]-2*dep[lca(p1,p2)]+1;
		return ans;
	}
}
```

## 