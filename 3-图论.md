# 图论

## 最近公共祖先

```cpp
const LL N = 5e5+10, SP = log2(N)+1;
vector<int> G[N];
int pa[N][SP], dep[N];

void dfs(int u, int fa) {
	pa[u][0] = fa; dep[u] = dep[fa] + 1;
	FOR (i, 1, SP) pa[u][i] = pa[pa[u][i - 1]][i - 1];
	for (int& v: G[u]) {
		if (v == fa) continue;
		dfs(v, u);
	}
}

int lca(int u, int v) {
	if (dep[u] < dep[v]) swap(u, v);
	int t = dep[u] - dep[v];
	FOR (i, 0, SP) if (t & (1 << i)) u = pa[u][i];
	FORD (i, SP - 1, -1) {
		int uu = pa[u][i], vv = pa[v][i];
		if (uu != vv) { u = uu; v = vv; }
	}
	return u == v ? u : pa[u][0];
}
```

## 网络流

- 最大流

```cpp
const LL INF = LONG_LONG_MAX;

struct E {
	LL to, cp;
	E(LL to, LL cp): to(to), cp(cp) {}
};

struct Dinic {
	static const LL M = 1E5 * 5;
	LL m, s, t;
	vector<E> edges;
	vector<LL> G[M];
	LL d[M];
	LL cur[M];
	
	void init(LL n, LL s, LL t) {
		this->s = s; this->t = t;
		for (LL i = 0; i <= n; i++) G[i].clear();
		edges.clear(); m = 0;
	}
	
	void addedge(LL u, LL v, LL cap) {
		edges.emplace_back(v, cap);
		edges.emplace_back(u, 0);
		G[u].push_back(m++);
		G[v].push_back(m++);
	}
	
	bool BFS() {
		memset(d, 0, sizeof d);
		queue<LL> Q;
		Q.push(s); d[s] = 1;
		while (!Q.empty()) {
			LL x = Q.front(); Q.pop();
			for (LL& i: G[x]) {
				E &e = edges[i];
				if (!d[e.to] && e.cp > 0) {
					d[e.to] = d[x] + 1;
					Q.push(e.to);
				}
			}
		}
		return d[t];
	}
	
	LL DFS(LL u, LL cp) {
		if (u == t || !cp) return cp;
		LL tmp = cp, f;
		for (LL& i = cur[u]; i < G[u].size(); i++) {
			E& e = edges[G[u][i]];
			if (d[u] + 1 == d[e.to]) {
				f = DFS(e.to, min(cp, e.cp));
				e.cp -= f;
				edges[G[u][i] ^ 1].cp += f;
				cp -= f;
				if (!cp) break;
			}
		}
		return tmp - cp;
	}
	
	LL go() {
		LL flow = 0;
		while (BFS()) {
			memset(cur, 0, sizeof cur);
			flow += DFS(s, INF);
		}
		return flow;
	}
} DC;
```

- 最小费用最大流

```cpp
const LL M = 5e4+10;
const int INF = INT_MAX;

struct E {
	int from, to, cp, v;
	E() {}
	E(int f, int t, int cp, int v) : from(f), to(t), cp(cp), v(v) {}
};

struct MCMF {
	int n, m, s, t;
	vector<E> edges;
	vector<int> G[M];
	bool inq[M];
	int d[M], p[M], a[M];
	
	void init(int _n, int _s, int _t) {
		n = _n; s = _s; t = _t;
		FOR (i, 0, n + 1) G[i].clear();
		edges.clear(); m = 0;
	}
	
	void addedge(int from, int to, int cap, int cost) {
		edges.emplace_back(from, to, cap, cost);
		edges.emplace_back(to, from, 0, -cost);
		G[from].push_back(m++);
		G[to].push_back(m++);
	}
	
	bool BellmanFord(int &flow, int &cost) {
		FOR (i, 0, n + 1) d[i] = INF;
		memset(inq, 0, sizeof inq);
		d[s] = 0, a[s] = INF, inq[s] = true;
		queue<int> Q; Q.push(s);
		while (!Q.empty()) {
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for (int& idx: G[u]) {
				E &e = edges[idx];
				if (e.cp && d[e.to] > d[u] + e.v) {
					d[e.to] = d[u] + e.v;
					p[e.to] = idx;
					a[e.to] = min(a[u], e.cp);
					if (!inq[e.to]) {
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if (d[t] == INF) return false;
		flow += a[t];
		cost += a[t] * d[t];
		int u = t;
		while (u != s) {
			edges[p[u]].cp -= a[t];
			edges[p[u] ^ 1].cp += a[t];
			u = edges[p[u]].from;
		}
		return true;
	}
	
	pair<int, int> go() {
		int flow = 0, cost = 0;
		while (BellmanFord(flow, cost));
		return {flow, cost};
	}
} MM;
```

## 树上路径交

- 前置模板：最近公共祖先

```cpp
int intersection(int x1, int y1, int x2, int y2) {
	int t[4] = {lca(x1, x2), lca(x1, y2), lca(y1, x2), lca(y1, y2)};
	int p1 = 0,p2 = 0;
	FOR(j,0,4)
	if(dep[t[j]] > dep[p1]) p2 = p1, p1 = t[j];
	else if(dep[t[j]] > dep[p2]) p2 = t[j];
	int h1 = lca(x1,y1), h2 = lca(x2,y2);
	if(p1 == p2){
		if(dep[p1] < dep[h1] || dep[p1] < dep[h2]) return 0;
		else return 1;
	}
	else{
		int ans = dep[p1]+dep[p2]-2*dep[lca(p1,p2)]+1;
		return ans;
	}
}
```

## 树上点分治（树的重心）

```cpp
const LL N = 2e4+10, N2 = N * 2;

int h[N], e[N2], ne[N2], idx;

void add(int a, int b){
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

vector<bool> vis;

// 获取子树的重心（自动处理父子关系）(如果有两个重心，输出编号小的那个)
// 若重心为u，则mx[u]为以u为重心子树大小的最大值
int q[N], fa[N], sz[N], mx[N];
int get_rt(int u) { 
	int p = 0, cur = -1;
	q[p++] = u; fa[u] = -1;
	while (++cur < p) {
		u = q[cur]; mx[u] = 0; sz[u] = 1;
		for (int i = h[u]; i!=-1; i=ne[i]){
			int j = e[i];
			if(vis[j] or j == fa[u]) continue;
			fa[q[p++] = j] = u;
		}
	}
	FORD (i, p - 1, -1) {
		u = q[i];
		mx[u] = max(mx[u], p - sz[u]);
		if (mx[u] * 2 <= p) return u;
		sz[fa[u]] += sz[u];
		mx[fa[u]] = max(mx[fa[u]], sz[u]);
	}
//	assert(0);
}

// 分治dfs（起点任意）
void dfs(int u) {
	cout << "u: " << u;
	u = get_rt(u);
	vis[u] = true;
	// 处理子树逻辑
	cout << " centroid: " << u << '\n';
	// 如果在此处DFS，会遍历整棵子树（if(vis[u]) return）
	// ...
	
	for(int i=h[u]; i!=-1; i=ne[i]){
		int j = e[i];
		if(vis[j]) continue;
		dfs(j);
	}
}
```

## 二分图

### 最大匹配

+ 最小覆盖数 = 最大匹配数
+ 最大独立集 = 顶点数 - 二分图匹配数
+ DAG 最小路径覆盖数 = 结点数 - 拆点后二分图最大匹配数

```cpp
const int N = 500+10;

struct MaxMatch {
	int n;
	vector<int> G[N];
	int vis[N], left[N], clk;
	
	void init(int n) {
		this->n = n;
		FOR (i, 0, n + 1) G[i].clear();
		memset(left, -1, sizeof left);
		memset(vis, -1, sizeof vis);
	}
	
	bool dfs(int u) {
		for (int v: G[u])
			if (vis[v] != clk) {
				vis[v] = clk;
				if (left[v] == -1 || dfs(left[v])) {
					left[v] = u;
					return true;
				}
			}
		return false;
	}
	
	int match() {
		int ret = 0;
		for (clk = 0; clk <= n; ++clk)
			if (dfs(clk)) ++ret;
		return ret;
	}
} MM;
// !!!!!!!!!!!!!!!!!!!!!!!!!!! Tester Start !!!!!!!!!!!!!!!!!!!!!!!!!!!!
void solve(){
	LL n1, n2, m, n, i, t1, t2;
	cin >> n1 >> n2 >> m;
	n = n1 + n2;
	MM.init(n);
	for(i=0; i<m; i++){
		cin >> t1 >> t2;
		MM.G[t1].push_back(n1+t2);
	}
	cout << MM.match() << '\n';
}
```

### 最大权匹配

- `py[j] = i` 表示右侧顶点 `j` 与左侧顶点 `i` 匹配

```cpp
namespace R {
	const int M = 400 + 5;
	const int INF = 2E9;
	int n;
	int w[M][M], kx[M], ky[M], py[M], vy[M], slk[M], pre[M];
	
	LL KM() {
		FOR (i, 1, n + 1)
		FOR (j, 1, n + 1)
		kx[i] = max(kx[i], w[i][j]);
		FOR (i, 1, n + 1) {
			fill(vy, vy + n + 1, 0);
			fill(slk, slk + n + 1, INF);
			fill(pre, pre + n + 1, 0);
			int k = 0, p = -1;
			for (py[k = 0] = i; py[k]; k = p) {
				int d = INF;
				vy[k] = 1;
				int x = py[k];
				FOR (j, 1, n + 1)
				if (!vy[j]) {
					int t = kx[x] + ky[j] - w[x][j];
					if (t < slk[j]) { slk[j] = t; pre[j] = k; }
					if (slk[j] < d) { d = slk[j]; p = j; }
				}
				FOR (j, 0, n + 1)
				if (vy[j]) { kx[py[j]] -= d; ky[j] += d; }
				else slk[j] -= d;
			}
			for (; k; k = pre[k]) py[k] = py[pre[k]];
		}
		LL ans = 0;
		FOR (i, 1, n + 1) ans += kx[i] + ky[i];
		return ans;
	}
}
// !!!!!!!!!!!!!!!!!!!!!!!!!!! Tester Start !!!!!!!!!!!!!!!!!!!!!!!!!!!!
void solve(){
	LL n1, n2, i, t1, t2, t3, m, n, j;
	cin >> n1 >> n2 >> m;
	// 初始化
	n = max(n1, n2);
	R::n = n;
	for(i=0; i<=n; i++){
		for(j=0; j<=n; j++){
			R::w[i][j] = 0;
		}
	}
	// 读数据
	for(i=0; i<m; i++){
		cin >> t1 >> t2 >> t3;
		R::w[t1][t2] = t3;
	}
	// 计算
	LL maxx = R::KM();
	cout << maxx << '\n';
	// 结果转换
	vector<pair<LL, LL>> anss;
	for(i=1; i<=n; i++){ // 注意遍历最大范围
		if(R::w[R::py[i]][i]){
			anss.push_back({R::py[i], i});
		}else{
			// 未匹配
			anss.push_back({R::py[i], 0});
		}
	}
	sort(anss.begin(), anss.end());
	for(i=0; i<n1; i++){
		cout << anss[i].second << ' ';
	}
}
```

## Tarjan

### 割点

+ 判断割点（无向图）
+ 注意原图可能不连通

```cpp
int dfn[N], low[N], clk;
void init() { clk = 0; memset(dfn, 0, sizeof dfn); }
void tarjan(int u, int fa) {
    low[u] = dfn[u] = ++clk;
    int cc = fa != -1;
    for (int& v: G[u]) {
        if (v == fa) continue;
        if (!dfn[v]) {
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            cc += low[v] >= dfn[u];
        } else low[u] = min(low[u], dfn[v]);
    }
    if (cc > 1) // u是割点
}
```

### 桥

- 无向图

+ 注意原图不连通和重边

```cpp
int dfn[N], low[N], clk;
void init() { memset(dfn, 0, sizeof dfn); clk = 0; }
void tarjan(int u, int fa) {
    low[u] = dfn[u] = ++clk;
    int _fst = 0;
    for (E& e: G[u]) {
        int v = e.to; if (v == fa && ++_fst == 1) continue;
        if (!dfn[v]) {
            tarjan(v, u);
            if (low[v] > dfn[u]) // (u, v)是桥
            low[u] = min(low[u], low[v]);
        } else low[u] = min(low[u], dfn[v]);
    }
}
```

### 强连通分量缩点

- 有向图
- `B`：强连通分量的数量计数器
- `bl[N]`：记录每个顶点所属的强连通分量编号
- `bcc[N]`：存储每个强连通分量包含的顶点列表

```cpp
int low[N], dfn[N], clk, B, bl[N];
vector<int> bcc[N];
void init() { B = clk = 0; memset(dfn, 0, sizeof dfn); }
void tarjan(int u) {
    static int st[N], p;
    static bool in[N];
    dfn[u] = low[u] = ++clk;
    st[p++] = u; in[u] = true;
    for (int& v: G[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (in[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        while (1) {
            int x = st[--p]; in[x] = false;
            bl[x] = B; bcc[B].push_back(x);
            if (x == u) break;
        }
        ++B;
    }
}
```

### 点双连通分量 / 广义圆方树

+ 数组开两倍
+ 一条边也被计入点双了（适合拿来建圆方树），可以用 点数 <= 边数 过滤
+ `B`：双连通分量的数量（编号从 0 开始）。
+ `bc[B]`：存储第 `B` 个双连通分量包含的节点。
+ `be[B]`：存储第 `B` 个双连通分量包含的边（索引）。
+ `bno[x]`：标记节点 `x` 属于哪个双连通分量（用于去重）。

```cpp
struct E { int to, nxt; } e[N];
int hd[N], ecnt;
void addedge(int u, int v) {
    e[ecnt] = {v, hd[u]};
    hd[u] = ecnt++;
}
int low[N], dfn[N], clk, B, bno[N];
vector<int> bc[N], be[N];
bool vise[N];
void init() {
    memset(vise, 0, sizeof vise);
    memset(hd, -1, sizeof hd);
    memset(dfn, 0, sizeof dfn);
    memset(bno, -1, sizeof bno);
    B = clk = ecnt = 0;
}

void tarjan(int u, int feid) {
    static int st[N], p;
    static auto add = [&](int x) {
        if (bno[x] != B) { bno[x] = B; bc[B].push_back(x); }
    };
    low[u] = dfn[u] = ++clk;
    for (int i = hd[u]; ~i; i = e[i].nxt) {
        if ((feid ^ i) == 1) continue;
        if (!vise[i]) { st[p++] = i; vise[i] = vise[i ^ 1] = true; }
        int v = e[i].to;
        if (!dfn[v]) {
            tarjan(v, i);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u]) {
                bc[B].clear(); be[B].clear();
                while (1) {
                    int eid = st[--p];
                    add(e[eid].to); add(e[eid ^ 1].to);
                    be[B].push_back(eid);
                    if ((eid ^ i) <= 1) break;
                }
                ++B;
            }
        } else low[u] = min(low[u], dfn[v]);
    }
}
```