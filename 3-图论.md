# 图论

## 最短路
### 朴素djikstra算法
- 无负权边、稠密图

```cpp
int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra(){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    for (int i = 0; i < n - 1; i ++ ){
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        st[t] = true;
    }
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
### 堆优化的djikstra
- 无负权边、稀疏图

```cpp
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra(){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号
    while (heap.size()){
        auto t = heap.top();
        heap.pop();
        int ver = t.second, distance = t.first;
        if (st[ver]) continue;
        st[ver] = true;
        for (int i = h[ver]; i != -1; i = ne[i]){
            int j = e[i];
            if (dist[j] > distance + w[i]){
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
### Bellman-Ford算法
- 有负权边、可以处理负环

```cpp
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge{    // 边，a表示出点，b表示入点，w表示边的权重
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford(){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ ){
        for (int j = 0; j < m; j ++ ){
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```
### spfa算法
- 有负权边、不能有负环，快

```cpp
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa(){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    queue<int> q;
    q.push(1);
    st[1] = true;
    while (q.size()){
        auto t = q.front();
        q.pop();
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if (dist[j] > dist[t] + w[i]){
                dist[j] = dist[t] + w[i];
                if (!st[j]){    // 如果队列中已存在j，则不需要将j重复插入
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
### spfa判断负环
```cpp
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N];     // 存储每个点是否在队列中

// 如果存在负环，则返回true，否则返回false。
bool spfa(){
    // 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。
    queue<int> q;
    for (int i = 1; i <= n; i ++ ){
        q.push(i);
        st[i] = true;
    }
    while (q.size()){
        auto t = q.front();
        q.pop();
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if (dist[j] > dist[t] + w[i]){
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (!st[j]){
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return false;
}
```
### floyd算法
```cpp
初始化：
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd(){
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```
## 最小生成树
### 朴素Prim算法

- 稠密图（ $m$ 接近于 $n^2$ ）

```cpp
int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中
// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim(){
    memset(dist, 0x3f, sizeof dist);
    int res = 0;
    for (int i = 0; i < n; i ++ ){
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        if (i && dist[t] == INF) return INF;
        if (i) res += dist[t];
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
    return res;
}
```
### Kruskal算法

- 实现简单，稀疏图（ $m$ 接近 $n$ ）

```cpp
int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组
struct Edge{    // 存储边
    int a, b, w;
    bool operator< (const Edge &W)const{
        return w < W.w;
    }
}edges[M];

int find(int x){    // 并查集核心操作
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal(){
    sort(edges, edges + m);
    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ ){
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a = find(a), b = find(b);
        if (a != b){    // 如果两个连通块不连通，则将这两个连通块合并
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
    if (cnt < n - 1) return INF;
    return res;
}
```
## 拓扑排序

- 有向图
- 别忘了存储入度
- 当 `toporder(int n)` 返回值的长度不等于 `n` 时，不存在拓扑排序。

```cpp
const int N = 1e5+10;
vector<int> G[N];
int deg[N]; // 入度

vector<int> toporder(int n) {
	vector<int> orders;
	queue<int> q;
	for (int i = 1; i <= n; i++)
		if (!deg[i]) {
			q.push(i);
			orders.push_back(i);
		}
	while (!q.empty()) {
		int u = q.front(); q.pop();
		for (int v: G[u])
			if (!--deg[v]) {
				q.push(v);
				orders.push_back(v);
			}
	}
	return orders;
}
```



## 最近公共祖先

```cpp
const LL N = 5e5+10, SP = log2(N)+1;
vector<int> G[N];
int pa[N][SP], dep[N];

void dfs(int u, int fa) {
	pa[u][0] = fa; dep[u] = dep[fa] + 1;
	FOR (i, 1, SP) pa[u][i] = pa[pa[u][i - 1]][i - 1];
	for (int& v: G[u]) {
		if (v == fa) continue;
		dfs(v, u);
	}
}

int lca(int u, int v) {
	if (dep[u] < dep[v]) swap(u, v);
	int t = dep[u] - dep[v];
	FOR (i, 0, SP) if (t & (1 << i)) u = pa[u][i];
	FORD (i, SP - 1, -1) {
		int uu = pa[u][i], vv = pa[v][i];
		if (uu != vv) { u = uu; v = vv; }
	}
	return u == v ? u : pa[u][0];
}
```

## 网络流

- 最大流

```cpp
const LL INF = LONG_LONG_MAX;

struct E {
	LL to, cp;
	E(LL to, LL cp): to(to), cp(cp) {}
};

struct Dinic {
	static const LL M = 1E5 * 5;
	LL m, s, t;
	vector<E> edges;
	vector<LL> G[M];
	LL d[M];
	LL cur[M];
	
	void init(LL n, LL s, LL t) {
		this->s = s; this->t = t;
		for (LL i = 0; i <= n; i++) G[i].clear();
		edges.clear(); m = 0;
	}
	
	void addedge(LL u, LL v, LL cap) {
		edges.emplace_back(v, cap);
		edges.emplace_back(u, 0);
		G[u].push_back(m++);
		G[v].push_back(m++);
	}
	
	bool BFS() {
		memset(d, 0, sizeof d);
		queue<LL> Q;
		Q.push(s); d[s] = 1;
		while (!Q.empty()) {
			LL x = Q.front(); Q.pop();
			for (LL& i: G[x]) {
				E &e = edges[i];
				if (!d[e.to] && e.cp > 0) {
					d[e.to] = d[x] + 1;
					Q.push(e.to);
				}
			}
		}
		return d[t];
	}
	
	LL DFS(LL u, LL cp) {
		if (u == t || !cp) return cp;
		LL tmp = cp, f;
		for (LL& i = cur[u]; i < G[u].size(); i++) {
			E& e = edges[G[u][i]];
			if (d[u] + 1 == d[e.to]) {
				f = DFS(e.to, min(cp, e.cp));
				e.cp -= f;
				edges[G[u][i] ^ 1].cp += f;
				cp -= f;
				if (!cp) break;
			}
		}
		return tmp - cp;
	}
	
	LL go() {
		LL flow = 0;
		while (BFS()) {
			memset(cur, 0, sizeof cur);
			flow += DFS(s, INF);
		}
		return flow;
	}
} DC;
```

- 最小费用最大流

```cpp
const LL M = 5e4+10;
const int INF = INT_MAX;

struct E {
	int from, to, cp, v;
	E() {}
	E(int f, int t, int cp, int v) : from(f), to(t), cp(cp), v(v) {}
};

struct MCMF {
	int n, m, s, t;
	vector<E> edges;
	vector<int> G[M];
	bool inq[M];
	int d[M], p[M], a[M];
	
	void init(int _n, int _s, int _t) {
		n = _n; s = _s; t = _t;
		FOR (i, 0, n + 1) G[i].clear();
		edges.clear(); m = 0;
	}
	
	void addedge(int from, int to, int cap, int cost) {
		edges.emplace_back(from, to, cap, cost);
		edges.emplace_back(to, from, 0, -cost);
		G[from].push_back(m++);
		G[to].push_back(m++);
	}
	
	bool BellmanFord(int &flow, int &cost) {
		FOR (i, 0, n + 1) d[i] = INF;
		memset(inq, 0, sizeof inq);
		d[s] = 0, a[s] = INF, inq[s] = true;
		queue<int> Q; Q.push(s);
		while (!Q.empty()) {
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for (int& idx: G[u]) {
				E &e = edges[idx];
				if (e.cp && d[e.to] > d[u] + e.v) {
					d[e.to] = d[u] + e.v;
					p[e.to] = idx;
					a[e.to] = min(a[u], e.cp);
					if (!inq[e.to]) {
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if (d[t] == INF) return false;
		flow += a[t];
		cost += a[t] * d[t];
		int u = t;
		while (u != s) {
			edges[p[u]].cp -= a[t];
			edges[p[u] ^ 1].cp += a[t];
			u = edges[p[u]].from;
		}
		return true;
	}
	
	pair<int, int> go() {
		int flow = 0, cost = 0;
		while (BellmanFord(flow, cost));
		return {flow, cost};
	}
} MM;
```

## 树上路径交

- 前置模板：最近公共祖先

```cpp
int intersection(int x1, int y1, int x2, int y2) {
	int t[4] = {lca(x1, x2), lca(x1, y2), lca(y1, x2), lca(y1, y2)};
	int p1 = 0,p2 = 0;
	FOR(j,0,4)
	if(dep[t[j]] > dep[p1]) p2 = p1, p1 = t[j];
	else if(dep[t[j]] > dep[p2]) p2 = t[j];
	int h1 = lca(x1,y1), h2 = lca(x2,y2);
	if(p1 == p2){
		if(dep[p1] < dep[h1] || dep[p1] < dep[h2]) return 0;
		else return 1;
	}
	else{
		int ans = dep[p1]+dep[p2]-2*dep[lca(p1,p2)]+1;
		return ans;
	}
}
```

## 树上点分治（树的重心）

```cpp
const LL N = 2e4+10, N2 = N * 2;

int h[N], e[N2], ne[N2], idx;

void add(int a, int b){
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

vector<bool> vis;

// 获取子树的重心（自动处理父子关系）(如果有两个重心，输出编号小的那个)
// 若重心为u，则mx[u]为以u为重心子树大小的最大值
int q[N], fa[N], sz[N], mx[N];
int get_rt(int u) { 
	int p = 0, cur = -1;
	q[p++] = u; fa[u] = -1;
	while (++cur < p) {
		u = q[cur]; mx[u] = 0; sz[u] = 1;
		for (int i = h[u]; i!=-1; i=ne[i]){
			int j = e[i];
			if(vis[j] or j == fa[u]) continue;
			fa[q[p++] = j] = u;
		}
	}
	FORD (i, p - 1, -1) {
		u = q[i];
		mx[u] = max(mx[u], p - sz[u]);
		if (mx[u] * 2 <= p) return u;
		sz[fa[u]] += sz[u];
		mx[fa[u]] = max(mx[fa[u]], sz[u]);
	}
//	assert(0);
}

// 分治dfs（起点任意）
void dfs(int u) {
	cout << "u: " << u;
	u = get_rt(u);
	vis[u] = true;
	// 处理子树逻辑
	cout << " centroid: " << u << '\n';
	// 如果在此处DFS，会遍历整棵子树（if(vis[u]) return）
	// ...
	
	for(int i=h[u]; i!=-1; i=ne[i]){
		int j = e[i];
		if(vis[j]) continue;
		dfs(j);
	}
}
```

## 二分图

### 最大匹配

+ 最小覆盖数 = 最大匹配数
+ 最大独立集 = 顶点数 - 二分图匹配数
+ DAG 最小路径覆盖数 = 结点数 - 拆点后二分图最大匹配数

```cpp
const int N = 500+10;

struct MaxMatch {
	int n;
	vector<int> G[N];
	int vis[N], left[N], clk;
	
	void init(int n) {
		this->n = n;
		FOR (i, 0, n + 1) G[i].clear();
		memset(left, -1, sizeof left);
		memset(vis, -1, sizeof vis);
	}
	
	bool dfs(int u) {
		for (int v: G[u])
			if (vis[v] != clk) {
				vis[v] = clk;
				if (left[v] == -1 || dfs(left[v])) {
					left[v] = u;
					return true;
				}
			}
		return false;
	}
	
	int match() {
		int ret = 0;
		for (clk = 0; clk <= n; ++clk)
			if (dfs(clk)) ++ret;
		return ret;
	}
} MM;
// !!!!!!!!!!!!!!!!!!!!!!!!!!! Tester Start !!!!!!!!!!!!!!!!!!!!!!!!!!!!
void solve(){
	LL n1, n2, m, n, i, t1, t2;
	cin >> n1 >> n2 >> m;
	n = n1 + n2;
	MM.init(n);
	for(i=0; i<m; i++){
		cin >> t1 >> t2;
		MM.G[t1].push_back(n1+t2);
	}
	cout << MM.match() << '\n';
}
```

### 最大权匹配

- `py[j] = i` 表示右侧顶点 `j` 与左侧顶点 `i` 匹配

```cpp
namespace R {
	const int M = 400 + 5;
	const int INF = 2E9;
	int n;
	int w[M][M], kx[M], ky[M], py[M], vy[M], slk[M], pre[M];
	
	LL KM() {
		FOR (i, 1, n + 1)
		FOR (j, 1, n + 1)
		kx[i] = max(kx[i], w[i][j]);
		FOR (i, 1, n + 1) {
			fill(vy, vy + n + 1, 0);
			fill(slk, slk + n + 1, INF);
			fill(pre, pre + n + 1, 0);
			int k = 0, p = -1;
			for (py[k = 0] = i; py[k]; k = p) {
				int d = INF;
				vy[k] = 1;
				int x = py[k];
				FOR (j, 1, n + 1)
				if (!vy[j]) {
					int t = kx[x] + ky[j] - w[x][j];
					if (t < slk[j]) { slk[j] = t; pre[j] = k; }
					if (slk[j] < d) { d = slk[j]; p = j; }
				}
				FOR (j, 0, n + 1)
				if (vy[j]) { kx[py[j]] -= d; ky[j] += d; }
				else slk[j] -= d;
			}
			for (; k; k = pre[k]) py[k] = py[pre[k]];
		}
		LL ans = 0;
		FOR (i, 1, n + 1) ans += kx[i] + ky[i];
		return ans;
	}
}
// !!!!!!!!!!!!!!!!!!!!!!!!!!! Tester Start !!!!!!!!!!!!!!!!!!!!!!!!!!!!
void solve(){
	LL n1, n2, i, t1, t2, t3, m, n, j;
	cin >> n1 >> n2 >> m;
	// 初始化
	n = max(n1, n2);
	R::n = n;
	for(i=0; i<=n; i++){
		for(j=0; j<=n; j++){
			R::w[i][j] = 0;
		}
	}
	// 读数据
	for(i=0; i<m; i++){
		cin >> t1 >> t2 >> t3;
		R::w[t1][t2] = t3;
	}
	// 计算
	LL maxx = R::KM();
	cout << maxx << '\n';
	// 结果转换
	vector<pair<LL, LL>> anss;
	for(i=1; i<=n; i++){ // 注意遍历最大范围
		if(R::w[R::py[i]][i]){
			anss.push_back({R::py[i], i});
		}else{
			// 未匹配
			anss.push_back({R::py[i], 0});
		}
	}
	sort(anss.begin(), anss.end());
	for(i=0; i<n1; i++){
		cout << anss[i].second << ' ';
	}
}
```

## Tarjan

### 割点

+ 判断割点（无向图）
+ 注意原图可能不连通

```cpp
int dfn[N], low[N], clk;
void init() { clk = 0; memset(dfn, 0, sizeof dfn); }
void tarjan(int u, int fa) {
    low[u] = dfn[u] = ++clk;
    int cc = fa != -1;
    for (int& v: G[u]) {
        if (v == fa) continue;
        if (!dfn[v]) {
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            cc += low[v] >= dfn[u];
        } else low[u] = min(low[u], dfn[v]);
    }
    if (cc > 1) // u是割点
}
```

### 桥

- 无向图

+ 注意原图不连通和重边

```cpp
int dfn[N], low[N], clk;
void init() { memset(dfn, 0, sizeof dfn); clk = 0; }
void tarjan(int u, int fa) {
    low[u] = dfn[u] = ++clk;
    int _fst = 0;
    for (E& e: G[u]) {
        int v = e.to; if (v == fa && ++_fst == 1) continue;
        if (!dfn[v]) {
            tarjan(v, u);
            if (low[v] > dfn[u]) // (u, v)是桥
            low[u] = min(low[u], low[v]);
        } else low[u] = min(low[u], dfn[v]);
    }
}
```

### 强连通分量缩点

- 有向图
- `B`：强连通分量的数量计数器
- `bl[N]`：记录每个顶点所属的强连通分量编号
- `bcc[N]`：存储每个强连通分量包含的顶点列表

```cpp
int low[N], dfn[N], clk, B, bl[N];
vector<int> bcc[N];
void init() { B = clk = 0; memset(dfn, 0, sizeof dfn); }
void tarjan(int u) {
    static int st[N], p;
    static bool in[N];
    dfn[u] = low[u] = ++clk;
    st[p++] = u; in[u] = true;
    for (int& v: G[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (in[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        while (1) {
            int x = st[--p]; in[x] = false;
            bl[x] = B; bcc[B].push_back(x);
            if (x == u) break;
        }
        ++B;
    }
}
```

### 点双连通分量 / 广义圆方树

+ 数组开两倍
+ 一条边也被计入点双了（适合拿来建圆方树），可以用 点数 <= 边数 过滤
+ `B`：双连通分量的数量（编号从 0 开始）。
+ `bc[B]`：存储第 `B` 个双连通分量包含的节点。
+ `be[B]`：存储第 `B` 个双连通分量包含的边（索引）。
+ `bno[x]`：标记节点 `x` 属于哪个双连通分量（用于去重）。

```cpp
struct E { int to, nxt; } e[N];
int hd[N], ecnt;
void addedge(int u, int v) {
    e[ecnt] = {v, hd[u]};
    hd[u] = ecnt++;
}
int low[N], dfn[N], clk, B, bno[N];
vector<int> bc[N], be[N];
bool vise[N];
void init() {
    memset(vise, 0, sizeof vise);
    memset(hd, -1, sizeof hd);
    memset(dfn, 0, sizeof dfn);
    memset(bno, -1, sizeof bno);
    B = clk = ecnt = 0;
}

void tarjan(int u, int feid) {
    static int st[N], p;
    static auto add = [&](int x) {
        if (bno[x] != B) { bno[x] = B; bc[B].push_back(x); }
    };
    low[u] = dfn[u] = ++clk;
    for (int i = hd[u]; ~i; i = e[i].nxt) {
        if ((feid ^ i) == 1) continue;
        if (!vise[i]) { st[p++] = i; vise[i] = vise[i ^ 1] = true; }
        int v = e[i].to;
        if (!dfn[v]) {
            tarjan(v, i);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u]) {
                bc[B].clear(); be[B].clear();
                while (1) {
                    int eid = st[--p];
                    add(e[eid].to); add(e[eid ^ 1].to);
                    be[B].push_back(eid);
                    if ((eid ^ i) <= 1) break;
                }
                ++B;
            }
        } else low[u] = min(low[u], dfn[v]);
    }
}
```