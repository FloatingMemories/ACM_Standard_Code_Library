# 字符串

## 最小表示法

- 寻找一个字符串的循环同构串中最小的那一个，输出偏移量

```cpp
int min_string(string s){
	int k = 0, i = 0, j = 1, n = s.length();
	while (k < n && i < n && j < n) {
		if (s[(i + k) % n] == s[(j + k) % n]) {
			k++;
		} else {
			s[(i + k) % n] > s[(j + k) % n] ? i = i + k + 1 : j = j + k + 1;
			if (i == j) i++;
			k = 0;
		}
	}
	return min(i, j);
}
```

## 字符串哈希

```cpp
// 双值哈希开关
#define ENABLE_DOUBLE_HASH

typedef long long LL;
typedef unsigned long long ULL;

const int x = 135;
const int N = 4e5 + 10;
const int p1 = 1e9 + 7, p2 = 1e9 + 9;
ULL xp1[N], xp2[N], xp[N];

void init_xp() {
	xp1[0] = xp2[0] = xp[0] = 1;
	for (int i = 1; i < N; ++i) {
		xp1[i] = xp1[i - 1] * x % p1;
		xp2[i] = xp2[i - 1] * x % p2;
		xp[i] = xp[i - 1] * x;
	}
}

struct String {
	string s;
	int length, subsize;
	bool sorted;
	ULL h[N], hl[N];
	
	// 预处理并返回全串哈希 O(n)
	ULL hash() {
		length = s.length();
		ULL res1 = 0, res2 = 0;
		h[length] = 0;  // ATTENTION!
		for (int j = length - 1; j >= 0; --j) {
#ifdef ENABLE_DOUBLE_HASH
			res1 = (res1 * x + s[j]) % p1;
			res2 = (res2 * x + s[j]) % p2;
			h[j] = (res1 << 32) | res2;
#else
			res1 = res1 * x + s[j];
			h[j] = res1;
#endif
			// printf("%llu\n", h[j]);
		}
		return h[0];
	}
	
	// 获取子串哈希，左闭右开区间 O(1)
	ULL get_substring_hash(int left, int right) const {
		int len = right - left;
#ifdef ENABLE_DOUBLE_HASH
		// get hash of s[left...right-1]
		unsigned int mask32 = ~(0u);
		ULL left1 = h[left] >> 32, right1 = h[right] >> 32;
		ULL left2 = h[left] & mask32, right2 = h[right] & mask32;
		return (((left1 - right1 * xp1[len] % p1 + p1) % p1) << 32) |
		(((left2 - right2 * xp2[len] % p2 + p2) % p2));
#else
		return h[left] - h[right] * xp[len];
#endif
	}
	
	void get_all_subs_hash(int sublen) {
		subsize = length - sublen + 1;
		for (int i = 0; i < subsize; ++i)
			hl[i] = get_substring_hash(i, i + sublen);
		sorted = 0;
	}
	
	void sort_substring_hash() {
		sort(hl, hl + subsize);
		sorted = 1;
	}
	
	bool match(ULL key) const {
//		if (!sorted) assert (0);
		if (!subsize) return false;
		return binary_search(hl, hl + subsize, key);
	}
	
	void init(string t) {
		length = t.length();
		s = t;
	}
};

String S, T; // 栈溢出

// 验证S中长度为ans的子串是否都存在于T中（是0否1）
int check(String &S, String &T, int ans) {
	if (T.length < ans) return 1;
	T.get_all_subs_hash(ans); T.sort_substring_hash();
	for (int i = 0; i < S.length - ans + 1; ++i)
		if (!T.match(S.get_substring_hash(i, i + ans)))
			return 1;
	return 0;
}

// 返回是否匹配
bool match_once(String &S, String &T){
	S.get_all_subs_hash(T.length);
	S.sort_substring_hash();
	return S.match(T.get_substring_hash(0, T.length));
}

// 返回匹配下标
vector<int> match_any(const String &text, const String &pattern) {
	vector<int> positions;
	int n = text.length;
	int m = pattern.length;

	if (m == 0 || m > n) return positions;
	
	ULL pattern_hash = pattern.get_substring_hash(0, m);
	
	for (int i = 0; i <= n - m; ++i) {
		ULL text_sub_hash = text.get_substring_hash(i, i + m);
		if (text_sub_hash == pattern_hash) {
			positions.push_back(i);
		}
	}
	return positions;
}

// 最长公共前缀 a[ai...] == b[bi...]
int LCP(const String &a, const String &b, int ai, int bi) {
	int l = 0, r = min(a.length - ai, b.length - bi);
	while (l < r) {
		int mid = (l + r + 1) / 2;
		if (a.get_substring_hash(ai, ai + mid) == b.get_substring_hash(bi, bi + mid))
			l = mid;
		else r = mid - 1;
	}
	return l;
}

// --------------------------- Template End ----------------------------
// !!!!!!!!!!!!!!!!!!!!!!!!!!! Tester Start !!!!!!!!!!!!!!!!!!!!!!!!!!!!

void solve(){
//	cout << "AA\n";
	init_xp();  // DON'T FORGET TO DO THIS!
//	cout << "BB\n";
	string s, t;
	cin >> s >> t;
	S.init(s), T.init(t);
	S.hash(), T.hash();
	cout << match_once(S, T) << '\n';
	
	vector<int> v = match_any(S, T);
	for(int ii: v) cout << ii << ' ';
	cout << '\n';
	
	cout << "LCP:" << LCP(S, T, 0, 0) << '\n';
	
	// S中所有长度为l的子串均在T中出现，且l最大
	LL l=0, r=S.length;
	while (l < r){
		int mid = l + r + 1 >> 1;
		if (!check(S, T, mid)) l = mid;
		else r = mid - 1;
	}
	cout << "check: " << l << '\n';
}

```

## 后缀自动机

- 状态：后缀状态
- 计算每个状态出现的次数
- 统计不同子串的数量
- 查找与s的最长公共子串长度
- 查找子串s的出现次数

```cpp
const LL N = 100005;

namespace sam {
	const int M = N << 1;
	int t[M][26], len[M] = {-1}, fa[M], cnt[M], sz = 2, last = 1;
	
	void init() {
		memset(t, 0, (sz + 10) * sizeof(t[0]));
		memset(cnt, 0, sizeof(cnt));
		sz = 2; 
		last = 1;
	}
	
	void ins(int ch) {
		int p = last, np = last = sz++;
		len[np] = len[p] + 1;
		cnt[np] = 1;  // 新创建的状态出现次数为1
		for (; p && !t[p][ch]; p = fa[p]) 
			t[p][ch] = np;
		if (!p) {
			fa[np] = 1;
			return;
		}
		int q = t[p][ch];
		if (len[p] + 1 == len[q]) {
			fa[np] = q;
		} else {
			int nq = sz++;
			len[nq] = len[p] + 1;
			memcpy(t[nq], t[q], sizeof(t[0]));
			fa[nq] = fa[q];
			fa[np] = fa[q] = nq;
			for (; t[p][ch] == q; p = fa[p]) 
				t[p][ch] = nq;
		}
	}
	
	int c[M] = {1}, a[M];
	void rsort() {
		FOR (i, 1, sz) c[i] = 0;
		FOR (i, 1, sz) c[len[i]]++;
		FOR (i, 1, sz) c[i] += c[i - 1];
		FOR (i, 1, sz) a[--c[len[i]]] = i;
	}
	
	// 计算每个状态的出现次数
	void calc_occurrences() {
		rsort();
		for (int i = sz - 1; i >= 0; --i) {
			int u = a[i];
			if (fa[u] > 1) {
				cnt[fa[u]] += cnt[u];
			}
		}
	}
}

// 统计不同子串的数量
long long count_distinct_substrings() {
	long long ans = 0;
	for (int i = 2; i < sam::sz; ++i) {
		ans += sam::len[i] - sam::len[sam::fa[i]];
	}
	return ans;
}

// 查找与s的最长公共子串长度
int longest_common_substring(const string &s) {
	int now = 1, current_len = 0, max_len = 0;
	for (char c : s) {
		int ch = c - 'a';
		while (now != 1 && !sam::t[now][ch]) {
			now = sam::fa[now];
			current_len = sam::len[now];
		}
		if (sam::t[now][ch]) {
			now = sam::t[now][ch];
			current_len++;
		}
		max_len = max(max_len, current_len);
	}
	return max_len;
}

// 查找子串s的出现次数
int find_occurrences(const string &s) {
	int now = 1;
	for (char c : s) {
		int ch = c - 'a';
		if (!sam::t[now][ch]) return 0;
		now = sam::t[now][ch];
	}
	return sam::cnt[now];
}
```

## 回文自动机

- 所有本质不同的回文串及其个数

```cpp
const int N = 100010;

namespace pam {
	int t[N][26], fa[N], len[N], rs[N], cnt[N], num[N];
	int sz, n, last;
	int _new(int l) {
		len[sz] = l; cnt[sz] = num[sz] = 0;
		return sz++;
	}
	void init() {
		memset(t, 0, sz * sizeof t[0]);
		rs[n = sz = 0] = -1;
		last = _new(0);
		fa[last] = _new(-1);
	}
	int get_fa(int x) {
		while (rs[n - 1 - len[x]] != rs[n]) x = fa[x];
		return x;
	}
	void ins(int ch) {
		rs[++n] = ch;
		int p = get_fa(last);
		if (!t[p][ch]) {
			int np = _new(len[p] + 2);
			num[np] = num[fa[np] = t[get_fa(fa[p])][ch]] + 1;
			t[p][ch] = np;
		}
		++cnt[last = t[p][ch]];
	}
}

// 计算每个回文子串的实际出现次数
void calc_count() {
	// 按长度从大到小排序节点
	int order[N];
	for (int i = 0; i < pam::sz; ++i) order[i] = i;
	sort(order, order + pam::sz, [&](int a, int b) {
		return pam::len[a] > pam::len[b];
	});
	
	// 从长回文串向短回文串累加计数
	for (int i = 0; i < pam::sz; ++i) {
		int v = order[i];
		if (pam::fa[v] != v) {  // 不是辅助节点
			pam::cnt[pam::fa[v]] += pam::cnt[v];
		}
	}
}

// 回溯获取所有回文串
void dfs(int u, string current, vector<pair<string, int>>& result) {
	if (pam::len[u] <= 0) {
		for (int c = 0; c < 26; ++c) {
			if (pam::t[u][c]) {
				char ch = 'a' + c;
				string new_str;
				if (pam::len[u] == -1) {
					new_str = string(1, ch);
				} else {
					new_str = string(1, ch) + current + string(1, ch);
				}
				dfs(pam::t[u][c], new_str, result);
			}
		}
		return;
	}
	
	result.emplace_back(current, pam::cnt[u]);
	
	for (int c = 0; c < 26; ++c) {
		if (pam::t[u][c]) {
			char ch = 'a' + c;
			string new_str = string(1, ch) + current + string(1, ch);
			dfs(pam::t[u][c], new_str, result);
		}
	}
}

// --------------------------- Template End ----------------------------
// !!!!!!!!!!!!!!!!!!!!!!!!!!! Tester Start !!!!!!!!!!!!!!!!!!!!!!!!!!!!

void solve(){
	string s;
	cout << "请输入字符串: ";
	cin >> s;
	
	// 初始化并构建回文自动机
	pam::init();
	for (char c : s) {
		pam::ins(c - 'a');  // 转换为0-25的范围
	}
	
	// 计算每个回文子串的实际出现次数
	calc_count();
	
	// 回溯获取所有本质不同的回文串
	vector<pair<string, int>> palindromes;
	dfs(0, "", palindromes);  // 从长度0的根节点开始
	dfs(1, "", palindromes);  // 从长度-1的根节点开始
	
	// 去重（某些特殊情况可能产生重复）
	sort(palindromes.begin(), palindromes.end());
	auto last = unique(palindromes.begin(), palindromes.end());
	palindromes.erase(last, palindromes.end());
	
	// 输出结果
	cout << "字符串: " << s << endl;
	cout << "本质不同的回文子串总数: " << palindromes.size() << endl;
	cout << "所有回文子串及其出现次数:" << endl;
	for (auto& [p, cnt] : palindromes) {
		cout << "回文串: \"" << p << "\", 出现次数: " << cnt << endl;
	}
}
```

